/*
 * Simulation setting to benchmark multivariate methods using real genotype data
 * Diego Garrido Mart√≠n 
 */

/*
 *  Define parameters
 */

// General params
params.GTdir = "$baseDir/simGT"
params.dir = 'result'
params.out = 'simulation.tsv'
params.help = false

// Simulation params
params.n = 100 // < simulateGT.nf
params.q = 3
params.p = 1000
params.r = 1
params.PTgen = 'matrixNorm'    
params.GTgen = 'simPopStructure' 
params.level = 0.05
params.s = 0
params.hs2 = 0.01 
params.hg2 = 0.3
params.alphaG = 0.5
params.lambda = 0.5
params.alphaH = 0.5
params.t = 'none'
params.m = 'none'

/*
 *  Print usage and help
 */

if (params.help) {
  log.info ''
  log.info 'Benchmark of GEMMA, GAMMA and MLM in a simulation using real GT data'
  log.info '======================================================================='
  log.info 'Simulations given a set of parameters'
  log.info ''
  log.info 'Usage: '
  log.info '    nextflow run simulate.nf [options]'
  log.info ''
  log.info 'Parameters:'
  log.info ' --n SAMPLE SIZE             total number of samples (default: 100)'
  log.info ' --q RESPONSES               number of response variables (default: 3)'
  log.info ' --p VARIANTS                number of variants to test (default: 1000)'
  log.info ' --r REPEAT                  times to repeat each simulation (default: 1)'
  log.info ' --PTgen PHENO GENERATION    phenotype data generation: matrixNorm or copula (default: matrixNorm)'
  log.info ' --GTgen GENO GENERATION     genotype data generation: simPopStructure, simUnrelated, simRelated, simEmpirical (default: simPopStructure)'
  log.info ' --GTdir GT DIR              input genotype directory with files generated by simulateGT.nf (default: data)' 
  log.info ' --level SIG LEVEL           significance level (default: 0.05)'
  log.info ' --s CAUSAL VARIANTS         number of causal variants (default: 0)'
  log.info ' --hs2 SNP HERITABILITY      average fraction of variance explained by causal variants across traits (default: 0.01)'
  log.info ' --hg2 REL HERITABILITY      average fraction of variance explained by relatedness across traits (default: 0.3)'
  log.info ' --alphaG REL SHARED         fraction of signal from the relatedness contribution shared across traits (default: 0.5)'
  log.info ' --lambda STRUCT NOISE       fraction of structured noise (default: 0.5)'
  log.info ' --alphaH S. NOISE SHARED    fraction of structured noise that is shared across traits (default: 0.5)'
  log.info ' --t TRANSFORM               transformation of response variables: none, PCA, GAMMA (default: none)'
  log.info ' --m MULTIPLE TESTING        perform multiple testing correction: none or any method in R:p.adjust (default: none)'
  log.info ' --dir OUTPUT DIR            output directory (default: result)'
  log.info ' --out OUTPUT                output file (default: simulation.tsv)'
  log.info ''
  exit(1)
}

/*
 *  Print parameter selection
 */

log.info ''
log.info 'SIMULATION SCHEMA'
log.info ''
log.info 'General parameters'
log.info '------------------'
log.info "Total sample size            : ${params.n}"
log.info "Number of responses          : ${params.q}"
log.info "Variants to test             : ${params.p}"
log.info "Repeats                      : ${params.r}"
log.info "Phenotype data generation    : ${params.PTgen}"
log.info "Genotype data generation     : ${params.GTgen}"
log.info "Genotype input directory     : ${params.GTdir}"
log.info "Significance level           : ${params.level}"
log.info "Number of causal variants    : ${params.s}"
log.info "Causal variant heritability  : ${params.hs2}"
log.info "Relatedness heritability     : ${params.hg2}"
log.info "Fraction of hg2 shared       : ${params.alphaG}"
log.info "Fraction of st. noise        : ${params.lambda}"
log.info "Fraction of st. noise shared : ${params.alphaH}"
log.info "Transformation               : ${params.t}"
log.info "Multiple testing correction  : ${params.m}"
log.info "Output directory             : ${params.dir}"
log.info "Output file                  : ${params.out}"
log.info ''

/*
 *  Expand parameters
 */

def grid = [:]
params.keySet().each{
  if(it in ['n','q','PTgen','GTgen','s','hs2','hg2','alphaG','lambda','alphaH','t','pca']){
    grid[it] = params[it]
  }
}

grid.keySet().each {
    if (grid[it] =~ /,/){
        grid[it] = grid[it].tokenize(',')
    } else if (grid[it] =~ /:/) {
        def (start, end, step) = grid[it].tokenize(':')
        def seq = []
        def val = start.toFloat()
        while(val.round(4) <= end.toFloat().round(4)){
            seq += val.round(4)
            val += step.toFloat().round(4)
        }
        grid[it] = seq
    }
}

/*
 *  Simulate phenotype
 */

process simulatePT {
 
    input:
    each n from grid.n
    each q from grid.q
    each PTgen from grid.PTgen
    each GT from Channel.from(grid.GTgen).map { ["${it}", file("${params.GTdir}/${it}.gemma"), file("${params.GTdir}/${it}.sXX.txt"), file("${params.GTdir}/${it}.eigenvec")] } 
    each s from grid.s
    each hs2 from grid.hs2
    each hg2 from grid.hg2
    each alphaG from grid.alphaG
    each lambda from grid.lambda
    each alphaH from grid.alphaH
    each r from Channel.from(1..params.r)

    output:    
    set val(q), file("geno.gemma"), file("kinship.txt"), file("pcs.txt"), file('pheno.txt'), file('ids.txt'), file('params.txt') into pheno1_ch, pheno2_ch, pheno3_ch

    script:
    def (GTgen, geno, kinship, eigenvec) = GT
    """
    # Save simulation parameters
    echo -e "$n\t$q\t$PTgen\t$GTgen\t$s\t$hs2\t$hg2\t$alphaG\t$lambda\t$alphaH\t$r" > params.txt
    
    # Subset genotype, kinship, eigenvec
    head -n $n $kinship | cut -f 1-$n > kinship.txt
    head -n \$(( $n + 1 )) $eigenvec > pcs.txt
    if [[ ${params.p} -lt \$(wc -l $geno | cut -d' ' -f 1) ]]; then
        head -n ${params.p} $geno | cut -d ',' -f 1-\$(( $n + 3 )) > "geno.gemma"
    else
        cut -d ',' -f 1-\$(( $n + 3 )) $geno > "geno.gemma"
    fi 

    # Simulate phenotypes
    simulatePT.R -r $r -n $n -q $q --PTgen $PTgen --geno geno.gemma --kinship kinship.txt -s $s --hs2 $hs2 --hg2 $hg2 --alphaG $alphaG --lambda $lambda --alphaH $alphaH -o pheno.txt -i ids.txt
    """
}

process GEMMA {

    input:
    set val(q), file(geno), file(kinship), file(eigenval), file(pheno), file(ids), file(par) from pheno1_ch
    
    output:
    file("gemma.txt") into gemma_ch

    script:
    def pids = (1..3).join(' ')
    """
    gemma -lmm -g $geno -k $kinship -p $pheno -n $pids -outdir . -o gemma
    tie.R -t gemma.assoc.txt -l ${params.level} -i $ids -m ${params.m} -o tieORpower.txt 
    paste $par <(echo "GEMMA") tieORpower.txt > gemma.txt
    """
}

process MLM {

    input:
    set val(q), file(geno), file(kinship), file(eigenval), file(pheno), file(ids), file(par) from pheno2_ch
    each t from grid.t
  
    output:
    file("mlm.txt") into mlm_ch

    script:
    if (t == 'none')
    """
    mlm.R -p $pheno -g $geno -t $t -o mlm.assoc.txt
    tie.R -t mlm.assoc.txt -l ${params.level} -i $ids -m ${params.m} -o tieORpower.txt 
    paste $par <(echo "MLM") tieORpower.txt > mlm.txt     
    """
    else if (t == 'PCA')
    """
    mlm.R -p $pheno -g $geno -t $t -c $eigenval -o mlm.assoc.txt   
    tie.R -t mlm.assoc.txt -l ${params.level} -i $ids -m ${params.m} -o tieORpower.txt
    paste $par <(echo "MLM_PCA") tieORpower.txt > mlm.txt
    """
    else if (t == 'GAMMA')
    """
    for i in {1..$q}; do 
        gemma -vc 2 -p $pheno -k $kinship -n \$i -outdir . -o VC &> /dev/null 
        grep -F "sigma2 estimates =" VC.log.txt | cut -d ' ' -f 7,9
    done > VC.txt 
    mlm.R -p $pheno -g $geno -t $t -k $kinship -v VC.txt -o mlm.assoc.txt
    tie.R -t mlm.assoc.txt -l ${params.level} -i $ids -m ${params.m} -o tieORpower.txt
    paste $par <(echo "MLM_GAMMA") tieORpower.txt > mlm.txt
    """
}

process MANOVA {

    input:
    set val(q), file(geno), file(kinship), file(eigenval), file(pheno), file(ids), file(par) from pheno3_ch
    each t from grid.t

    output:
    file("manova.txt") into manova_ch

    script:
    if (t == 'none')
    """
    mlm.R -p $pheno -g $geno -t $t -o manova.assoc.txt --manova
    tie.R -t manova.assoc.txt -l ${params.level} -i $ids -m ${params.m} -o tieORpower.txt
    paste $par <(echo "MANOVA") tieORpower.txt > manova.txt
    """
    else if (t == 'PCA')
    """
    mlm.R -p $pheno -g $geno -t $t -o manova.assoc.txt -c $eigenval --manova
    tie.R -t manova.assoc.txt -l ${params.level} -i $ids -m ${params.m} -o tieORpower.txt
    paste $par <(echo "MANOVA_PCA") tieORpower.txt > manova.txt
    """
    else if (t == 'GAMMA')
    """
    for i in {1..$q}; do
        gemma -vc 2 -p $pheno -k $kinship -n \$i -outdir . -o VC &> /dev/null
        grep -F "sigma2 estimates =" VC.log.txt | cut -d ' ' -f 7,9
    done > VC.txt
    mlm.R -p $pheno -g $geno -t $t -k $kinship -v VC.txt -o manova.assoc.txt --manova
    tie.R -t manova.assoc.txt -l ${params.level} -i $ids -m ${params.m} -o tieORpower.txt 
    paste $par <(echo "MANOVA_GAMMA") tieORpower.txt > manova.txt
    """
}

gemma_ch.mix(mlm_ch, manova_ch).collectFile(name: "${params.out}", sort: { it.text }).set{pub_ch}

process end {

   publishDir "${params.dir}"

   input:
   file(sim) from pub_ch

   output:
   file(sim) into end_ch

   script:
   """
   sed -i "1 s/^/n\tq\tPTgen\tGTgen\ts\ths2\thg2\talphaG\tlambda\talphaH\tr\\n/" $sim
   """
}

