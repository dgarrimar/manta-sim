#!/bin/env nextflow

/*
 * Copyright (c) 2021, Diego Garrido-Mart√≠n
 *
 * Simulation setting to benchmark the TIE and power of multivariate 
 * methods (MANTA, MANOVA and GEMMA) in the context of multi-trait 
 * GWAS studies.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */


/*
 *  Define parameters
 */

// General params
params.dir = 'result'
params.out = 'simulation.tsv'
params.fx = "$baseDir/supp"
params.help = false

// Simulation params
params.n = 100 
params.q = 3
params.p = 100
params.PTgen = 'mvnorm'    
params.GTdir = null
params.GTgen = null 
params.level = 0.05
params.m = 'none'
params.hs2 = 0 
params.hg2 = 0
params.C = 'none'
params.k = 5
params.t = 'none'
params.scale = false
params.maf = 0
params.c = 10
params.gemma = true

// PTgen: MVN, MVT or copula definition
params.varG = 'random'
params.varE = 'random'
params.varGr = 2
params.varEr = 2
params.corG = 0
params.corE = 0
params.b = 'equal'
params.ub = 2
params.a = params.q

// PTgen: MVN
params.hk = 1
params.chk = 1

// PTgen: simplex (proportions) or multinomial
params.p_loc = 1


/*
 *  Print usage and help
 */

if (params.help) {
    log.info ''
    log.info 'S I M U L A T E - N F'
    log.info '======================================================================='
    log.info 'Benchmark MANTA, MANOVA and GEMMA in extensive simulations'
    log.info ''
    log.info 'Usage: '
    log.info '    nextflow run simulate.nf [options]'
    log.info ''
    log.info 'Parameters:'
    log.info ' --n SAMPLE SIZE             total number of samples (default: 100)'
    log.info ' --q RESPONSES               number of response variables (default: 3)'
    log.info ' --p VARIANTS                number of variants to test (default: 100)'
    log.info ' --PTgen PHENO GENERATION    phenotype data (residual) generation: mvnorm, simplex, multinom or copula definition (default: mvnorm)'
    log.info ' --GTgen GENO GENERATION     genotype data file (prefix) generated by simulateGT.nf'
    log.info ' --GTdir GT DIR              directory with genotype data files generated by simulateGT.nf' 
    log.info ' --level SIG LEVEL           significance level (default: 0.05)'
    log.info ' --m MULTIPLE TESTING        perform multiple testing correction: none or any method in R/p.adjust (default: none)'
    log.info ' --hs2 SNP HERITABILITY      average fraction of variance explained by causal variant across traits (default: 0)'
    log.info ' --hg2 REL HERITABILITY      average fraction of variance explained by relatedness across traits (default: 0)'
    log.info ' --C COVARIATES              include covariates: none, PCA (default: none)' 
    log.info ' --k NUMBER PC               number of genotype PCs (default: 5)'
    log.info ' --t TRANSFOMATION           response variable transformation: none, sqrt, log (default: none)'
    log.info ' --scale SCALE               [WARNING] scale the response variables for MANTA/MANOVA (default: false)'
    log.info ' --maf CUSTOM MAF            simulate biallelic SNPs following a binomial model [if 0, dismiss] (default: 0)'
    log.info ' --c NUMBER CHUNKS           number of chunks (default: 10)'
    log.info ' --fx FUNCTIONS              path to helper functions and precomputed datasets (default: ./supp)'
    log.info ' --gemma GEMMA               run GEMMA in addition to MANTA and MANOVA (default: true)'
    log.info ' --dir OUTPUT DIR            output directory (default: result)'
    log.info ' --out OUTPUT                output file (default: simulation.tsv)'
    log.info ''
    log.info 'Additional parameters for PTgen mvnorm, mvt or copula:'
    log.info ' --varG VARIANCE G           genotype variances: equal, unequal, random (default: random)'
    log.info ' --varE VARIANCE E           error variances: equal, unequal, random (default: random)'
    log.info ' --varGr VARIANCE RATIO      max/min ratio between genotype variances [--varG unequal] (default = 2)'
    log.info ' --varEr VARIANCE RATIO      max/min ratio between error variances [--varE unequal] (default = 2)'
    log.info ' --corG CORRELATION G        genotype correlations when varG is not random (default: 0)'
    log.info ' --corE CORRELATION E        error correlations when varE is not random (default: 0)'
    log.info ' --b EFFECT TYPE             type of effects: equal, unequal, block (default: equal)'
    log.info ' --ub EFFECT RATIO           max/min ratio of effects [--b unequal] (default: 2)'
    log.info ' --a NUMBER AFFECTED         [WARNING] number of responses affected by causal variant when --h2s is not 0 [--b equal] (default: q)'
    log.info ''
    log.info 'Additional parameters for PTgen mvnorm:'
    log.info ' --hk HETEROSCEDASTIC        variance ratio between minor and major genotype groups [--varE random] (default: 1)'
    log.info ' --chk HETEROSCEDASTIC       covariance ratio between minor and major genotype groups [--varE random] (default: 1)'
    log.info ''
    log.info 'Additional parameters for PTgen simplex or multinomial:'
    log.info ' --p_loc LOCATION            parameter location, 1 is centered (default: 1)'
    log.info ''
    exit(1)
}


/*
 *  Print parameter selection
 */

log.info ''
log.info 'SIMULATION SCHEMA'
log.info ''
log.info 'Parameters'
log.info '------------------'
log.info "Total sample size            : ${params.n}"
log.info "Number of responses          : ${params.q}"
log.info "Variants to test             : ${params.p}"
log.info "Phenotype data generation    : ${params.PTgen}"
log.info "Genotype data generation     : ${params.GTgen}"
log.info "Genotype input directory     : ${params.GTdir}"
log.info "Significance level           : ${params.level}"
log.info "Multiple testing correction  : ${params.m}"
log.info "Causal variant heritability  : ${params.hs2}"
log.info "Relatedness heritability     : ${params.hg2}"
log.info "Covariates                   : ${params.C}"
log.info "Number of PCs                : ${params.k}"
log.info "Transformation               : ${params.t}"
log.info "Scale responses [WARNING]    : ${params.scale}"
log.info "Custom MAF                   : ${params.maf}"
log.info "Number of chunks             : ${params.c}"
log.info "Helper functions             : ${params.fx}"
log.info "Run GEMMA                    : ${params.gemma}"
log.info "Output directory             : ${params.dir}"
log.info "Output file                  : ${params.out}"
log.info ''
if (params.PTgen == 'simplex' || params.PTgen == "multinom") {
    log.info 'Additional parameters'
    log.info '---------------------'
    log.info "Parameter location           : ${params.p_loc}"
} else {
    log.info 'Additional parameters'
    log.info '---------------------'
    log.info "Variances (G)                : ${params.varG}"
    log.info "Variances (E)                : ${params.varE}"
    log.info "Ratio variances (G)          : ${params.varGr}"
    log.info "Ratio variances (E)          : ${params.varEr}"
    log.info "Correlations (G)             : ${params.corG}"
    log.info "Correlations (E)             : ${params.corE}"
    log.info "Type of effects              : ${params.b}"
    log.info "Max/min effect ratio         : ${params.ub}"
    log.info "Responses affected [WARNING] : ${params.a}"
    if (params.PTgen == "mvnorm") {
        log.info "Heteroscedasticity (var)     : ${params.hk}"
        log.info "Heteroscedasticity (cov)     : ${params.chk}"
    }
}
log.info ''


/*
 *  Checks
 */ 


// Mandatory options

if (!params.GTdir) {
    exit 1, "Genotype data folder not specified."
} else if (!params.GTgen) {
    exit 1, "Genotype data file file not specified."
}

// The number of variants and chunks should be compatible

if (params.p%params.c != 0) {
    exit 1, "ERROR: p%c should be 0"
}


/*
 *  Expand parameters
 */

def grid = [:]
params.keySet().each {
    if (it in ['n','q','PTgen','GTgen','hs2','hg2','varG','varE','varGr','varEr','corG','corE','b','ub','p_loc','hk','chk','maf','C','m','a']) {
        grid[it] = params[it]
    }
}

def grid2ch = grid.clone() 
grid.keySet().each {
    if (grid[it] =~ /,/) {
        grid[it] = grid[it].tokenize(',')
        grid2ch[it] = Channel.fromList(grid[it].clone())
    } else if (grid[it] =~ /:/) {
        def (start, end, step) = grid[it].tokenize(':')
        def seq = []
        def val = start.toFloat()
        while(val.toFloat().round(4) <= end.toFloat().round(4)) {
            seq += val.round(4)
            val += step.toFloat().round(4)
        }
        grid[it] = seq
        grid2ch[it] = Channel.fromList(seq)
    } else {
        grid2ch[it] = Channel.of(grid[it])
    }
}

grid2ch.n
.combine(grid2ch.q)
.combine(grid2ch.PTgen)
.combine(grid2ch.GTgen)
.map{
    id = [it[3] + "|n=" + it[0]]
    it = id + it
}.set{grid_ch}


/*
 *  Prepare genotype 
 */

process prepare {

    tag { id }

    input:
    each n from grid.n
    each GT from Channel.from(grid.GTgen).map { ["${it}", file("${params.GTdir}/${it}")] }

    output:
    tuple val(id), file("${GTgen}.pruned.bed"), file("${GTgen}.pruned.bim"), file("${GTgen}.pruned.fam") into geno_pruned_ch1, geno_pruned_ch2
    tuple val(id), file("${GTgen}.thin.bed"), file("${GTgen}.thin.bim"), file("${GTgen}.thin.fam") into geno_thin_ch

    script:
    (GTgen, prefix) = GT
    id = "$GTgen|n=$n"
    """
    # Subset n and prune
    if [[ $n -lt \$(wc -l ${prefix}.fam | cut -d ' ' -f 1) ]]; then
        head -n $n ${prefix}.fam > keep.txt
    else
        cut -f2 ${prefix}.fam > keep.txt
    fi

    plink2 --bfile $prefix --indep-pairwise 50 5 0.1 --keep keep.txt --out $GTgen --threads 1
    plink2 --bfile $prefix --extract ${GTgen}.prune.in --keep keep.txt --out ${GTgen}.pruned --make-bed --threads 1
    
    # Thin: subset n and p 
    plink2 --bfile $prefix --seed 1 --thin-count $params.p --keep keep.txt --out ${GTgen}.thin --make-bed --threads 1
    """
}


/*  
 *  Compute kinship
 */

process kinship {

    tag { id }

    input:
    tuple val(id), file(bed), file(bim), file(fam) from geno_pruned_ch1
 
    output:
    tuple val(id), file("${GTgen}.sXX.txt.gz") into kinship_ch

    script:
    GTgen = id.split("\\|")[0]
    """
    # Compute kinship
    export OPENBLAS_NUM_THREADS=1
    sed -i 's/-9/1/' $fam    
    gemma -gk 2 -bfile \$(basename $bed | sed 's/.bed//') -outdir . -o $GTgen 
    gzip ${GTgen}.sXX.txt
    """
}

if ("PCA" in grid.C) {

   /*
    *  Genotype PCA
    */

    process pca {

        tag { id }

        input:
        tuple val(id), file(bed), file(bim), file(fam) from geno_pruned_ch2

        output:
        tuple val(id), file("${GTgen}.eigenvec") into pca_ch

        script:
        GTgen = id.split("\\|")[0]
        """
        # Compute PCs using all variants
        if [[ \$(wc -l $fam | cut -d' ' -f2) -ge 5000 ]]; then approx="approx"; else approx=""; fi
        plink2 --bfile ${GTgen}.pruned --pca ${params.k} \$approx --out ${GTgen} --threads 1
        """
    }

    grid_ch.combine(geno_thin_ch, by:0).combine(kinship_ch, by: 0).combine(pca_ch, by: 0).set{gt2pt_ch}

} else {

    grid_ch.combine(geno_thin_ch, by:0).combine(kinship_ch, by: 0).spread(Channel.of("")).set{gt2pt_ch}

}


/*
 *  Simulate phenotype
 */ 

process simulate_test {

    tag { "$par|$C" }

    input:
    tuple id, n, q, PTgen, GTgen, file(bed), file(bim), file(fam), file(kinship), file(eigenval) from gt2pt_ch
    each c from Channel.fromList(1..params.c)
    each hs2 from grid.hs2
    each hg2 from grid.hg2
    each varG from grid.varG
    each varE from grid.varE
    each varGr from grid.varGr
    each varEr from grid.varEr
    each corG from grid.corG
    each corE from grid.corE
    each b from grid.b
    each ub from grid.ub
    each p_loc from grid.p_loc
    each hk from grid.hk
    each chk from grid.chk
    each maf from grid.maf
    each C from grid.C
    each a from grid.a

    output:
    tuple par_gemma, file('gemma.assoc.txt') optional true into gemma_v_ch
    tuple par_manta, file('manta.assoc.txt') into manta_v_ch
    tuple par_manova, file('manova.assoc.txt') into manova_v_ch

    script:
    par = "$n|$q|$PTgen|$GTgen|$hs2|$hg2|$varG|$varE|$varGr|$varEr|$corG|$corE|$b|$ub|$p_loc|$hk|$chk|$maf|$a"
    par_gemma = "$par|GEMMA"
    par_manta = "$par|MANTA_$C"
    par_manova = "$par|MANOVA_$C" 
    pids = (1..q.toInteger()).join(' ')
    single = C
    if (grid.C instanceof List) {
       single = grid.C[0]
    }
    if (params.scale == true) {scale = "--scale"} else {scale = ""}
    if (maf != 0) {min_maf = "-maf 0.0001"} else {min_maf = "-maf 0.01"}
    """ 
    # Manage chunks
    start=\$(( ($c-1)*(${params.p}/${params.c}) + 1 ))
    end=\$(( $c*(${params.p}/${params.c}) ))
 
    for (( v=\$start; v<=(\$end); v++ )); do

        if [[ $maf == 0 ]]; then
            # Extract single variant
            sed -n \${v}p $bim | awk '{print \$1"\t"\$4-1"\t"\$4}' > variant.bed
            plink2 --bfile \$(basename $bed | sed 's/.bed//') --extract bed0 variant.bed --out geno --make-bed --threads 1
        else 
            binGT.R -s \$v -n $n -m $maf -o dummy.vcf
            plink2 --vcf dummy.vcf --make-bed --out geno
        fi

        # Double check that is unique
        if [[ \$(cat geno.bim | wc -l) -gt 1 ]]; then continue; fi
 
        # Simulate phenotype
        simulatePT.R -s \$v -n $n -q $q --PTgen $PTgen --geno geno --kinship $kinship --hs2 $hs2 --hg2 $hg2 --varG $varG --varE $varE --vGr $varGr --vEr $varEr --corG $corG --corE $corE --b $b --ub $ub --p_loc $p_loc -t ${params.t} --hk $hk --chk $chk -o pheno.txt --fx ${params.fx} -a $a

        # Run MANTA/MANOVA
        if [[ $C == 'PCA' ]]; then
            manta.R -p pheno.txt -g geno -c $eigenval -k ${params.k} --manta manta_\$v.assoc.txt --manova manova_\$v.assoc.txt $scale -$min_maf
        else 
            manta.R -p pheno.txt -g geno --manta manta_\$v.assoc.txt --manova manova_\$v.assoc.txt $scale -$min_maf 
        fi

        # Run GEMMA once
        if [[ ${params.gemma} == true && $single == $C ]]; then
            export OPENBLAS_NUM_THREADS=1
            paste <(cut -f1-5 geno.fam) pheno.txt > tmpfile; mv tmpfile geno.fam
            (timeout 120 gemma -lmm -b geno -k $kinship -n $pids -outdir . -o gemma_\$v $min_maf &> STATUS || exit 0)
            if [[ \$(grep ERROR STATUS) ]]; then
                touch gemma_\$v.assoc.txt
                continue
            else
                gemma -lmm -b geno -k $kinship -n $pids -outdir . -o gemma_\$v $min_maf
                sed '1d' gemma_\$v.assoc.txt | awk '{print \$2"\t"\$NF}' > tmpfile; mv tmpfile gemma_\$v.assoc.txt
            fi
       fi

    done
    cat manta_*.assoc.txt > manta.assoc.txt
    cat manova_*.assoc.txt > manova.assoc.txt
    if [[ ${params.gemma} == true && $single == $C ]]; then
        cat gemma_*.assoc.txt > gemma.assoc.txt
    fi
    """
}

gemma_v_ch.collectFile(sort: { it.name }).map() {[it.name, it]}.set{gemma_ch}
manta_v_ch.collectFile(sort: { it.name }).map() {[it.name, it]}.set{manta_ch}
manova_v_ch.collectFile(sort: { it.name }).map() {[it.name, it]}.set{manova_ch}

gemma_ch.concat(manta_ch, manova_ch).set{tie_power_ch}

 
/*
 *  Compute TIE/power
 */

process tie {

    tag{ "$par|$m" }   
 
    input:
    each m from grid.m
    tuple par, file(assoc) from tie_power_ch
 
    output:
    file("res.txt") into out_ch  

    script:
    """
    tie.R -t $assoc -l ${params.level} -m $m -o tieORpower.txt
    paste <(echo -e "$par|$m" | sed 's/|/\t/g') tieORpower.txt > res.txt
    """
}

out_ch.collectFile(name: "${params.out}", sort: { it.text }).set{pub_ch}

process end {

   publishDir "${params.dir}", mode: 'copy'

   input:
   file(sim) from pub_ch

   output:
   file(sim) into end_ch

   script:
   """
   sed -i "1 s/^/n\tq\tPTgen\tGTgen\ths2\thg2\tVarG\tVarE\tVarGr\tVarEr\tcorG\tcorE\tb\tub\tp_loc\thk\tchk\tmaf\ta\tmethod\tmtc\ttie\\n/" $sim
   """
}

